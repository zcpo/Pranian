/**
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for all private data,
 * ensuring users can only access their own information. All user-specific data,
 * such as profiles and subscriptions, is nested under a `/users/{userId}` path.
 *
 * Data Structure:
 * - /users/{userId}: Private user profile.
 * - /users/{userId}/subscriptions/{subscriptionId}: User's private subscription info.
 * - /subscriptionTiers, /products, /productCategories, /contentTypes: Publicly
 *   readable collections containing catalog-style data. These are read-only for
 *   clients, intended to be managed via a trusted backend/admin process.
 * - /content: A semi-public collection. Listing is available to any signed-in
 *   user, but reading individual content documents is restricted to users with
 *   an active subscription.
 *
 * Key Security Decisions:
 * - Strict User Data Segregation: All user data is locked down to the owner via
 *   path-based security (`isOwner()`). Listing all users is explicitly forbidden.
 * - Read-Only Public Data: Top-level collections that store shared application
 *   data (like product categories or subscription tiers) are configured to be
 *   publicly readable but not writable by any client. This provides a secure
 *   default, preventing unauthorized modification of shared app state.
 * - Subscription-Gated Content: Access to individual documents in the `/content`
 *   collection is protected. A user must be signed-in and have an active
 *   subscription to read a specific piece of content. This requires performing
 *   a check against the user's subscription document.
 * - Prototyping Flexibility: Data shape and type validation are intentionally
 *   omitted to allow for rapid development. Security focuses solely on
 *   authorization (who can access what) and relational integrity (e.g., ensuring
 *   a user's ID is correctly stored on documents they create).
 *
 * Denormalization for Authorization:
 * To secure the `/content` collection, rules must verify a user's subscription
 * status. This is achieved by first reading the user's profile to find their
 * `subscriptionId`, then reading the corresponding subscription document to check
 * its `endDate`. While this involves two `get()` calls, it is necessary to
 * enforce this security requirement with the current data structure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     * @param userId The UID to check against the request's auth token.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if a document exists and if the requester is the owner.
     * Used for safe update and delete operations.
     * @param userId The UID of the document owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user has an active subscription.
     * NOTE: This function performs two 'get' operations, which increases cost
     * and latency. It first reads the user's profile to find their subscriptionId,
     * then reads the subscription document to check its end date. This is
     * necessary for securely gating content based on the provided data model.
     * @param userId The UID of the user to check.
     */
    function isSubscribed(userId) {
      // Get the user's profile to find their subscriptionId.
      let userProfile = get(/databases/$(database)/documents/users/$(userId)).data;
      // Get the user's subscription document using the ID from their profile.
      let subscription = get(/databases/$(database)/documents/users/$(userId)/subscriptions/$(userProfile.subscriptionId)).data;
      // An active subscription must have an endDate in the future.
      return subscription.endDate > request.time;
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) A new user creating their own profile document. `auth.uid` must match `userId`.
     * @deny (list) An authenticated user trying to list all user profiles in the database.
     * @principle Restricts access to a user's own data tree and enforces self-creation.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // CRITICAL: Prevents listing all users.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's subscription records.
     * @path /users/{userId}/subscriptions/{subscriptionId}
     * @allow (get) An authenticated user reading their own subscription details.
     * @deny (update) An authenticated user trying to modify another user's subscription.
     * @principle Enforces path-based ownership for a user's private subcollections.
     */
    match /users/{userId}/subscriptions/{subscriptionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == subscriptionId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores the available subscription tiers (e.g., Free, Paid).
     * @path /subscriptionTiers/{subscriptionTierId}
     * @allow (list) Any client (authenticated or not) listing the available tiers.
     * @deny (create) Any client trying to create a new subscription tier.
     * @principle Provides public read access for catalog data, with writes disabled for clients.
     */
    match /subscriptionTiers/{subscriptionTierId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores product information for the e-commerce store.
     * @path /products/{productId}
     * @allow (get) Any client reading the details of a single product.
     * @deny (update) Any client trying to change the price of a product.
     * @principle Provides public read access for catalog data, with writes disabled for clients.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores product categories (e.g., Merchandise, Events).
     * @path /productCategories/{productCategoryId}
     * @allow (list) Any client listing all available product categories.
     * @deny (delete) Any client trying to delete a category.
     * @principle Provides public read access for catalog data, with writes disabled for clients.
     */
    match /productCategories/{productCategoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores yoga and meditation content.
     * @path /content/{contentId}
     * @allow (get) A signed-in user with an active subscription reading a piece of content.
     * @deny (get) A signed-in user without an active subscription trying to read content.
     * @principle Enforces complex business logic (subscription status) for read access.
     */
    match /content/{contentId} {
      allow get: if isSignedIn() && isSubscribed(request.auth.uid);
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores content types (e.g., Article, Video, Audio).
     * @path /contentTypes/{contentTypeId}
     * @allow (get) Any client reading a content type document.
     * @deny (create) Any client trying to create a new content type.
     * @principle Provides public read access for catalog data, with writes disabled for clients.
     */
    match /contentTypes/{contentTypeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}